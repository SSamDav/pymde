

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>MDE &mdash; pymde 0.1.6 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/autoclasstoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Preprocessing" href="../preprocess/index.html" />
    <link rel="prev" title="Getting started" href="../getting_started/index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pymde
          

          
          </a>

          
            
            
              <div class="version">
                v0.1.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">CONTENTS</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/index.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">MDE</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-mde-framework">The MDE framework</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#embedding-matrix">Embedding matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distortion-functions">Distortion functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#distortion-functions-from-weights">Distortion functions from weights</a></li>
<li class="toctree-l4"><a class="reference internal" href="#distortion-functions-from-deviations">Distortion functions from deviations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#average-distortion">Average distortion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constraints">Constraints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#constructing-an-mde-problem">Constructing an MDE problem</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#items">Items</a></li>
<li class="toctree-l3"><a class="reference internal" href="#edges">Edges</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distortion-function">Distortion function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constraint">Constraint</a></li>
<li class="toctree-l3"><a class="reference internal" href="#construction">Construction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#embedding">Embedding</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id2">Distortion functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#penalties">Penalties</a></li>
<li class="toctree-l3"><a class="reference internal" href="#losses">Losses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id3">Constraints</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#centered">Centered</a></li>
<li class="toctree-l3"><a class="reference internal" href="#standardized">Standardized</a></li>
<li class="toctree-l3"><a class="reference internal" href="#anchored">Anchored</a></li>
<li class="toctree-l3"><a class="reference internal" href="#custom-constraints">Custom constraints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#computing-embeddings">Computing embeddings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sanity-checking-embeddings">Sanity-checking embeddings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#plotting-embeddings">Plotting embeddings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-cdf-of-distortions">The CDF of distortions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#outliers">Outliers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#comparing-embeddings">Comparing embeddings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#embedding-new-points">Embedding new points</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../preprocess/index.html">Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../datasets/index.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citing/index.html">Citing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pymde</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>MDE</li>
    
    
    <li class="wy-breadcrumbs-aside">
    <a href="https://github.com/cvxgrp/pymde">View source</a>
    </li>
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mde">
<span id="id1"></span><h1>MDE<a class="headerlink" href="#mde" title="Permalink to this headline">¶</a></h1>
<p>The central concept in PyMDE is the Minimum-Distortion Embedding (MDE) problem.
An MDE problem is an optimization problem whose solution is an embedding.</p>
<p>We can interpret an MDE problem as a declarative description of the properties
an embedding should satisfy. MDE problems in PyMDE are represented by
the <a class="reference internal" href="../api/index.html#pymde.MDE" title="pymde.MDE"><code class="xref any py py-class docutils literal notranslate"><span class="pre">pymde.MDE</span></code></a> object.</p>
<p>In this part of the tutorial, we explain what an MDE problem is. Then we
show how to construct MDE problems using PyMDE, with custom objective
functions and constraints. We also describe some of the useful methods that
the <a class="reference internal" href="../api/index.html#pymde.MDE" title="pymde.MDE"><code class="xref any py py-class docutils literal notranslate"><span class="pre">pymde.MDE</span></code></a> class provides, and how to sanity-check and compare
embeddings.</p>
<div class="section" id="the-mde-framework">
<h2>The MDE framework<a class="headerlink" href="#the-mde-framework" title="Permalink to this headline">¶</a></h2>
<p>In this section, we introduce the concept of an MDE problem, whose solution
is an embedding. At a high-level, the objective of an MDE problem
is to minimally distort known relationships between some pairs of items,
while possibly satisfying some constraints.</p>
<p>We first explain this abstractly. In the next section, we show how to make MDE
problems using PyMDE.</p>
<div class="section" id="embedding-matrix">
<h3>Embedding matrix<a class="headerlink" href="#embedding-matrix" title="Permalink to this headline">¶</a></h3>
<p>An MDE problem starts with a set <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> of <span class="math notranslate nohighlight">\(n\)</span> items,
<span class="math notranslate nohighlight">\(\mathcal{V} = \{0, 1, ..., n - 1\}\)</span>. An embedding of the set of items is
a matrix <span class="math notranslate nohighlight">\(X \in \mathbf{R}^{n \times m}\)</span>,
where <span class="math notranslate nohighlight">\(m\)</span> is the <em>embedding dimension</em>. The rows of <span class="math notranslate nohighlight">\(X\)</span> are denoted
<span class="math notranslate nohighlight">\(x_0, x_1, \ldots, x_{n-1}\)</span>, with <span class="math notranslate nohighlight">\(x_i\)</span> being the <em>embedding vector</em>
associated with item <span class="math notranslate nohighlight">\(i\)</span>. The quality of an embedding will depend only on
the Euclidean distances between the embedding vectors,</p>
<div class="math notranslate nohighlight">
\[d_{ij} = \|x_i - x_j\|_2, \quad i, j = 0, \ldots, n - 1.\]</div>
</div>
<div class="section" id="distortion-functions">
<h3>Distortion functions<a class="headerlink" href="#distortion-functions" title="Permalink to this headline">¶</a></h3>
<p>We make our preferences on the
<span class="math notranslate nohighlight">\(d_{ij}\)</span> concrete with <em>distortion functions</em> associated with the
edges. These have the form</p>
<div class="math notranslate nohighlight">
\[f_{ij} : \mathbf{R}_{+} \to \mathbf{R}_+, \quad (i, j) \in \mathcal E\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal E\)</span> is a set of edges <span class="math notranslate nohighlight">\((i , j)\)</span>, with
<span class="math notranslate nohighlight">\(0 \leq i &lt; j &lt; n\)</span>. This set of edges may contain all pairs, or a subset
of pairs, but it must be non-empty.</p>
<p>For convenience, we can assume the edges are listed in some fixed order,
and label them as <cite>1, 2, ldots, p</cite>, where <span class="math notranslate nohighlight">\(p = |\mathcal E|\)</span>.
We can then represent the collection of distortion functions as a single
vector distortion function <span class="math notranslate nohighlight">\(f : \mathbf{R}^p \to \mathbf{R}^p\)</span>, where
<span class="math notranslate nohighlight">\(p = |\mathcal E|\)</span> and <span class="math notranslate nohighlight">\(f_k\)</span> is the distortion function associated
with the <span class="math notranslate nohighlight">\(k\)</span>-th edge.</p>
<p>Distortion functions are usually derived either from weights, or from
original distances or deviations between some pairs of items. PyMDE
provides a library of both types of distortion functions, in
<a class="reference internal" href="../api/index.html#module-pymde.penalties" title="pymde.penalties"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">pymde.penalties</span></code></a> and <a class="reference internal" href="../api/index.html#module-pymde.losses" title="pymde.losses"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">pymde.losses</span></code></a>.</p>
<div class="section" id="distortion-functions-from-weights">
<h4>Distortion functions from weights<a class="headerlink" href="#distortion-functions-from-weights" title="Permalink to this headline">¶</a></h4>
<p>We start with nonzero weights <span class="math notranslate nohighlight">\(w_1, w_2, \ldots, w_p\)</span>, one for each edge.
A positive weight means the items in the edge are similar, and a negative
weight means they are disimilar. The larger the weight is, the more similar
the items are; the more negative the weight, the more dissimilar.</p>
<p>A vector distortion function  <span class="math notranslate nohighlight">\(f : \mathbf{R}^{p} \to \mathbf{R}^p\)</span>
derived from weights has component functions</p>
<div class="math notranslate nohighlight">
\[\begin{split}f_k(d) = \begin{cases}
    w_k p_{\text{attractive}}(d_k) &amp; w_k &gt; 0 \\
    w_k p_{\text{repulsive}}(d_k) &amp; w_k &lt; 0 \\
\end{cases}.\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(w_k\)</span> is a scalar weight and <span class="math notranslate nohighlight">\(p_{\text{attractive}}\)</span> and
<span class="math notranslate nohighlight">\(p_{\text{repulsive}}\)</span> are penalty functions. Penalty functions are
increasing functions: the attractive penalty encourages the distances to
be small, while the repulsive penalty encourages them to be large, or at least.
not small.</p>
<p>Attractive penalties are 0 when the input is 0, and grow otherwise. The
attractive and repulsive penalties can be the same, e.g. they can both be
quadratics <span class="math notranslate nohighlight">\(d \mapsto d^2\)</span>, or they can be different. Typically, though,
repulsive penalties go to negative infinity as the input approaches 0, and
to 0 as the input grows large.</p>
</div>
<div class="section" id="distortion-functions-from-deviations">
<h4>Distortion functions from deviations<a class="headerlink" href="#distortion-functions-from-deviations" title="Permalink to this headline">¶</a></h4>
<p>A vector distortion function <span class="math notranslate nohighlight">\(f : \mathbf{R}^{p} \to \mathbf{R}^p\)</span>
derived from original deviations has component functions</p>
<div class="math notranslate nohighlight">
\[f_k(d_k) = \ell(d_k, \delta_k), \quad k=1, \ldots, p,\]</div>
<p>where
<span class="math notranslate nohighlight">\(\ell\)</span> is a loss function,
and <span class="math notranslate nohighlight">\(\delta_k\)</span> is a scalar deviation or dissimilarity score associated
with the <span class="math notranslate nohighlight">\(k\)</span>-th edge.</p>
<p>The deviations can be interpreted as targets for the embedding distances:
the loss function is 0 when <span class="math notranslate nohighlight">\(d_k = \delta_k\)</span>, and positive otherwise.
So a deviation <span class="math notranslate nohighlight">\(\delta_k\)</span> of 0 means that the items in the k-th edge
are the same, and the larger the deviation, the more dissimilar the items are.</p>
<p>The simplest example of a loss function is the squared loss</p>
<div class="math notranslate nohighlight">
\[\ell(d, \delta) = (d - \delta)^2.\]</div>
</div>
</div>
<div class="section" id="average-distortion">
<h3>Average distortion<a class="headerlink" href="#average-distortion" title="Permalink to this headline">¶</a></h3>
<p>The value <span class="math notranslate nohighlight">\(f_{ij}(d_{ij})\)</span> is the <em>distortion</em> associated for the
pair <span class="math notranslate nohighlight">\((i, j) \in \mathcal E\)</span>. The smaller the distortion, the better
the embedding captures the relationship between <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>The goal is to minimize the <em>average distortion</em> of the embedding <cite>X</cite>, defined
as</p>
<div class="math notranslate nohighlight">
\[E(X) = \frac{1}{|\mathcal E|} \sum_{(i, j) \in \mathcal E} f_{ij} (d_{ij}),\]</div>
<p>possibly subject to the constraint that <span class="math notranslate nohighlight">\(X \in \mathcal X\)</span>, where
<span class="math notranslate nohighlight">\(\mathcal X\)</span> is a set of permissible embeddings. This gives the
optimization problem</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{ll}
\mbox{minimize} &amp; E(X) \\
\mbox{subject to} &amp; X \in \mathcal X.
\end{array}\end{split}\]</div>
<p>This optimization problem is called an <strong>MDE problem</strong>. Its solution
is the embedding.</p>
</div>
<div class="section" id="constraints">
<h3>Constraints<a class="headerlink" href="#constraints" title="Permalink to this headline">¶</a></h3>
<p>We can optionally impose constraints on the embedding.</p>
<p>For example, we can enforce the embedding vectors to be <strong>standardized</strong>,
which means that they are centered and identity covariance, that is,
<span class="math notranslate nohighlight">\((1/n) X^T X = I\)</span>. When a standardization constraint is imposed,
the embedding problem always has a solution. Additionally, the standardization
constraint forces the embedding to spread out. When using distortion functions
from weights, this means we do not need repulsive penalties (but can choose
to include them anyway).</p>
<p>Or, we can <strong>anchor</strong> or pin some of the embedding vectors to fixed values.</p>
</div>
</div>
<div class="section" id="constructing-an-mde-problem">
<h2>Constructing an MDE problem<a class="headerlink" href="#constructing-an-mde-problem" title="Permalink to this headline">¶</a></h2>
<p>In PyMDE, instances of the <a class="reference internal" href="../api/index.html#pymde.MDE" title="pymde.MDE"><code class="xref any py py-class docutils literal notranslate"><span class="pre">pymde.MDE</span></code></a> class are MDE problems. The
<a class="reference internal" href="../api/index.html#pymde.preserve_neighbors" title="pymde.preserve_neighbors"><code class="xref any py py-func docutils literal notranslate"><span class="pre">pymde.preserve_neighbors</span></code></a> and <a class="reference internal" href="../api/index.html#pymde.preserve_distances" title="pymde.preserve_distances"><code class="xref any py py-func docutils literal notranslate"><span class="pre">pymde.preserve_distances</span></code></a>
functions we saw in the previous part of the tutorial both returned
<code class="docutils literal notranslate"><span class="pre">MDE</span></code> instances.</p>
<p>To create an MDE instance, we need to specify five things:</p>
<ul class="simple">
<li><p>the number of items;</p></li>
<li><p>the embedding dimension;</p></li>
<li><p>the list of edges (a <code class="docutils literal notranslate"><span class="pre">torch.Tensor</span></code>, of shape <code class="docutils literal notranslate"><span class="pre">(n_edges,</span> <span class="pre">2)</span></code>)</p></li>
<li><p>the vector distortion function; and</p></li>
<li><p>an optional constraint.</p></li>
</ul>
<p>Let’s walk through a very simple example.</p>
<div class="section" id="items">
<h3>Items<a class="headerlink" href="#items" title="Permalink to this headline">¶</a></h3>
<p>Let’s say we have five items.
In PyMDE, items are represented by consecutive integer labels, in our case
0, 1, 2, 3, and 4.</p>
</div>
<div class="section" id="edges">
<h3>Edges<a class="headerlink" href="#edges" title="Permalink to this headline">¶</a></h3>
<p>Say we know that item 0 is similar to items 1 and 4, 1 is
similar to 2, 2 is similar to 3, and 3 is similar to 4. We include these
pairs in a list of edges</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
</pre></div>
</div>
</div>
<div class="section" id="distortion-function">
<h3>Distortion function<a class="headerlink" href="#distortion-function" title="Permalink to this headline">¶</a></h3>
<p>Next, we need to encode the fact that each edge
represents some degree of similarity between the items it contains. We’ll use a
quadratic penalty <span class="math notranslate nohighlight">\(f_k(d_k) = w_k d_k^2\)</span> (other choices are possible).
We’ll associate a weight 1 to the first edge, 2 to the second edge, 5 to the
third edge, and 6 to the fourth edge; this conveys that 0 is somewhat similar
to 1 but more similar to 4, 2 is yet more similar to 3, and 3 is yet more
similar to 4. We write this in PyMDE as</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">])</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">pymde</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">Quadratic</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="constraint">
<h3>Constraint<a class="headerlink" href="#constraint" title="Permalink to this headline">¶</a></h3>
<p>The last thing to specify is the constraint. Since we’re using a distortion
function based on only positive weights, we’ll need a standardization
constraint.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">constraint</span> <span class="o">=</span> <span class="n">pymde</span><span class="o">.</span><span class="n">Standardized</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="construction">
<h3>Construction<a class="headerlink" href="#construction" title="Permalink to this headline">¶</a></h3>
<p>We can now construct the MDE problem:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pymde</span>

<span class="n">mde</span> <span class="o">=</span> <span class="n">pymde</span><span class="o">.</span><span class="n">MDE</span><span class="p">(</span>
  <span class="n">n_items</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
  <span class="n">embedding_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
  <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span>
  <span class="n">distortion_function</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
  <span class="n">constraint</span><span class="o">=</span><span class="n">pymde</span><span class="o">.</span><span class="n">Standardized</span><span class="p">())</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">mde</span></code> object represents the MDE problem whose goal is to minimize
the average distortion with respect to <code class="docutils literal notranslate"><span class="pre">f</span></code>, subject to the standardization
constraint. This object can be thought of describing the kind of embedding
we would like.</p>
</div>
<div class="section" id="embedding">
<h3>Embedding<a class="headerlink" href="#embedding" title="Permalink to this headline">¶</a></h3>
<p>To obtain the embedding, we call the <a class="reference internal" href="../api/index.html#pymde.MDE.embed" title="pymde.MDE.embed"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">pymde.MDE.embed</span></code></a> method:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">embedding</span> <span class="o">=</span> <span class="n">mde</span><span class="o">.</span><span class="n">embed</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">tensor</span><span class="p">([[</span> <span class="mf">0.0894</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.8689</span><span class="p">],</span>
        <span class="p">[</span><span class="o">-</span><span class="mf">0.7726</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1450</span><span class="p">],</span>
        <span class="p">[</span><span class="o">-</span><span class="mf">0.6687</span><span class="p">,</span>  <span class="mf">0.5428</span><span class="p">],</span>
        <span class="p">[</span><span class="o">-</span><span class="mf">0.5557</span><span class="p">,</span>  <span class="mf">0.9696</span><span class="p">],</span>
        <span class="p">[</span> <span class="mf">1.9077</span><span class="p">,</span>  <span class="mf">0.5015</span><span class="p">]])</span>
</pre></div>
</div>
<p>We can check that the embedding is standardized with the following code:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">embedding</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="n">mde</span><span class="o">.</span><span class="n">n_items</span><span class="p">)</span><span class="o">*</span><span class="n">embedding</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">embedding</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">tensor</span><span class="p">([</span><span class="mf">4.7684e-08</span><span class="p">,</span> <span class="mf">5.9605e-08</span><span class="p">])</span>
<span class="n">tensor</span><span class="p">([[</span><span class="mf">1.0000e+00</span><span class="p">,</span> <span class="mf">7.4506e-08</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">7.4506e-08</span><span class="p">,</span> <span class="mf">1.0000e+00</span><span class="p">]])</span>
</pre></div>
</div>
<p>We can also evaluate the average distortion:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">mde</span><span class="o">.</span><span class="n">average_distortion</span><span class="p">(</span><span class="n">embedding</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">tensor</span><span class="p">(</span><span class="mf">6.2884</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>This very simple example showed all the components required
to construct an MDE problem. The full documentation for the MDE
class is available in the <a class="reference internal" href="../api/index.html#api-mde"><span class="std std-ref">API documentation</span></a>.</p>
<p>In the next section, we’ll learn more about distortion functions and
how to create them.</p>
</div>
</div>
<div class="section" id="id2">
<h2>Distortion functions<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>A distortion function is just a Python callable that maps the embedding
distances to distortions, using PyTorch operations. Its call signature should
be</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_edges</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_edges</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
</pre></div>
</div>
<p>For example, the quadratic penalty we used previously can be implemented as</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">distances</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">weights</span> <span class="o">*</span> <span class="n">distances</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>A quadratic penalty based on original deviations could be implemented as</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">deviations</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">distances</span><span class="p">):</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">distances</span> <span class="o">-</span> <span class="n">deviations</span><span class="p">)</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>In many applications, you won’t need to implement your own distortion functions.
Instead, you can choose one from a library of useful distortion functions
that PyMDE provides.</p>
<p>PyMDE provides two types of distortion functions: penalties, which are
based on weights, and losses, based on original deviations. (A natural
question is: Where do the weights or original deviations come from?
We’ll see some recipes for creating edges and their weights / deviations in the
next part of the tutorial, which covers <a class="reference internal" href="../preprocess/index.html#preprocess"><span class="std std-ref">preprocessing</span></a>.)</p>
<div class="section" id="penalties">
<h3>Penalties<a class="headerlink" href="#penalties" title="Permalink to this headline">¶</a></h3>
<p>Penalties: distortion functions derived from weights.</p>
<p>A vector distortion function  <span class="math notranslate nohighlight">\(f : \mathbf{R}^{p} \to \mathbf{R}^p\)</span>
derived from weights has component functions</p>
<div class="math notranslate nohighlight">
\[f_k(d_k) = w_kp(d_k), \quad k=1, \ldots, p,\]</div>
<p>where <span class="math notranslate nohighlight">\(w_k\)</span> is a scalar weight, <span class="math notranslate nohighlight">\(p\)</span> is a penalty function, and
<span class="math notranslate nohighlight">\(d_k\)</span> is an embedding distance. The penalty encourages distances to be
small when the weights are positive, and encourages them to be not small
when the weights are negative.</p>
<p>When an MDE problem calls a distortion function, <span class="math notranslate nohighlight">\(d_k\)</span> is the Euclidean
distance between the items paired by the <span class="math notranslate nohighlight">\(k\)</span>-th edge, so <span class="math notranslate nohighlight">\(w_k\)</span>
should be the weight associated with the <span class="math notranslate nohighlight">\(k\)</span>-th edge, and
<span class="math notranslate nohighlight">\(f_k(d_k)\)</span> is the distortion associated with the edge.</p>
<p>Every penalty can be used with positive or negative weights. When <span class="math notranslate nohighlight">\(w_k\)</span>
is positive, <span class="math notranslate nohighlight">\(f_k\)</span> is attractive, meaning it encourages the embedding
distances to be small; when <span class="math notranslate nohighlight">\(w_k\)</span> is negative, <span class="math notranslate nohighlight">\(f_k\)</span> is repulsive,
meaning it encourages the distances to be large. Some penalties are better
suited to attracting points, while others are better suited to repelling them.</p>
<p><strong>Negative weights.</strong>
For negative weights, it is recommended to only use one of the
following penalties:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pymde</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">Log</span>
<span class="n">pymde</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">InvPower</span>
<span class="n">pymde</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">LogRatio</span>
</pre></div>
</div>
<p>These penalties go to negative infinity as the input approaches zero,
and to zero as the input approaches infinity. With a negative weight,
that means the distortion function goes to infinity at 0, and to 0 at infinity.</p>
<p>Using other penalties with negative weights is possible, but it can lead to
pathological MDE problems if you are not careful.</p>
<p><strong>Positive weights.</strong>
Penalties that work well in attracting points are those that are <span class="math notranslate nohighlight">\(0\)</span>
when the distance is <span class="math notranslate nohighlight">\(0\)</span>, grows when the distance is larger than
<span class="math notranslate nohighlight">\(0\)</span>. All the penalties in this module, other than the ones listed above
(and the function described below), can be safely used with attractive
penalties. Some examples inlcude:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pymde</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">Log1p</span>
<span class="n">pymde</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">Linear</span>
<span class="n">pymde</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">Quadratic</span>
<span class="n">pymde</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">Cubic</span>
<span class="n">pymde</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">Huber</span>
</pre></div>
</div>
<p><strong>Combining penalties.</strong>
The <code class="docutils literal notranslate"><span class="pre">PushAndPull</span></code> function can be used to combine two penalties, an attractive
penalty for use with positive weights, and a repulsive penalty for use with
negative weights. This leads to a distortion function of the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}f_k(d) = \begin{cases}
    w_k p_{\text{attractive}}(d_k) &amp; w_k &gt; 0 \\
    w_k p_{\text{repulsive}}(d_k) &amp; w_k &lt; 0 \\
\end{cases}.\end{split}\]</div>
<p>For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">])</span>
<span class="n">attractive_penalty</span> <span class="o">=</span> <span class="n">pymde</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">Log1p</span>
<span class="n">repulsive_penalty</span> <span class="o">=</span> <span class="n">pymde</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">Log</span>

<span class="n">distortion_function</span> <span class="o">=</span> <span class="n">pymde</span><span class="o">.</span><span class="n">PushAndPull</span><span class="p">(</span>
    <span class="n">weights</span><span class="p">,</span>
    <span class="n">attractive_penalty</span><span class="p">,</span>
    <span class="n">repulsive_penalty</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example.</strong>
Distortion functions are created in a vectorized or elementwise fashion. The
constructor takes a sequence (torch.Tensor) of weights, returning a callable
object. The object takes a sequence of distances of the same length as the
weights, and returns a sequence of distortions, one for each distance.</p>
<p>For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">])</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">pymde</span><span class="o">.</span><span class="n">penalties</span><span class="o">.</span><span class="n">Quadratic</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

<span class="n">distances</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">])</span>
<span class="n">distortions</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
<span class="c1"># the distortions are 1 * 2**2 == 4, 2 * 1**2 == 2, 3 * 4**2 = 48</span>
<span class="nb">print</span><span class="p">(</span><span class="n">distortions</span><span class="p">)</span>
</pre></div>
</div>
<p>prints</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">48.</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="losses">
<h3>Losses<a class="headerlink" href="#losses" title="Permalink to this headline">¶</a></h3>
<p>Losses: distortion functions derived from original deviations.</p>
<p>A vector distortion function <span class="math notranslate nohighlight">\(f : \mathbf{R}^{p} \to \mathbf{R}^p\)</span>
derived from original deviations has component functions</p>
<div class="math notranslate nohighlight">
\[f_k(d_k) = \ell(d_k, \delta_k), \quad k=1, \ldots, p,\]</div>
<p>where
<span class="math notranslate nohighlight">\(\ell\)</span> is a loss function, <span class="math notranslate nohighlight">\(\delta_k\)</span> is a nonnegative deviation
or dissimilarity score, <span class="math notranslate nohighlight">\(d_k\)</span> is an embedding distance,</p>
<p>When an MDE problem calls a distortion function, <span class="math notranslate nohighlight">\(d_k\)</span> is the Euclidean
distance between the items paired by the k-th edge, so <span class="math notranslate nohighlight">\(\delta_k\)</span> should
be the original deviation associated with the k-th edge, and <span class="math notranslate nohighlight">\(f_k(d_k)\)</span>
is the distortion associated with the edge.</p>
<p>The deviations can be interpreted as targets for the embedding distances:
the loss function is 0 when <span class="math notranslate nohighlight">\(d_k = \delta_k\)</span>, and positive otherwise.
So a deviation <span class="math notranslate nohighlight">\(\delta_k\)</span> of 0 means that the items in the k-th edge
are the same, and the larger the deviation, the more dissimilar the items are.</p>
<p>Distortion functions are created in a vectorized or elementwise fashion. The
constructor takes a sequence (torch.Tensor) of deviations (target distances),
returning a callable object. The object takes a sequence of distances of the
same length as the weights, and returns a sequence of distortions, one for each
distance.</p>
<p>Some examples of losses inlcude:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pymde</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">Absolute</span>
<span class="n">pymde</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">Quadratic</span>
<span class="n">pymde</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">SoftFractional</span>
</pre></div>
</div>
<p><strong>Example.</strong></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">deviations</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">])</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">pymde</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">Quadratic</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

<span class="n">distances</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">])</span>
<span class="n">distortions</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
<span class="c1"># the distortions are (2 - 1)**2 == 1, (5 - 2)**2 == 9, (4 - 3)**2 = 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">distortions</span><span class="p">)</span>
</pre></div>
</div>
<p>prints</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">9.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id3">
<h2>Constraints<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>PyMDE currently provides three constraint sets:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../api/index.html#pymde.Centered" title="pymde.Centered"><code class="xref any py py-func docutils literal notranslate"><span class="pre">pymde.Centered</span></code></a>, which constrains the embedding vectors to have mean zero;</p></li>
<li><p><a class="reference internal" href="../api/index.html#pymde.Standardized" title="pymde.Standardized"><code class="xref any py py-func docutils literal notranslate"><span class="pre">pymde.Standardized</span></code></a>, which constrains the embedding vectors to have identity covariance (and have mean zero);</p></li>
<li><p><a class="reference internal" href="../api/index.html#pymde.Anchored" title="pymde.Anchored"><code class="xref any py py-class docutils literal notranslate"><span class="pre">pymde.Anchored</span></code></a>, which pins specific items (called anchors) to specific values (i.e., this is an equality constraint on a subset of the embedding vectors).</p></li>
</ul>
<div class="section" id="centered">
<h3>Centered<a class="headerlink" href="#centered" title="Permalink to this headline">¶</a></h3>
<p>If a constraint is not specified, the embedding will be centered, but no other
restrictions will be placed on it. Centering is without loss of generality,
since translating all the points does not affect the average distortion.</p>
<p>To explicitly create a centering constraint, use</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">constraint</span> <span class="o">=</span> <span class="n">pymde</span><span class="o">.</span><span class="n">Centered</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="standardized">
<h3>Standardized<a class="headerlink" href="#standardized" title="Permalink to this headline">¶</a></h3>
<p>The standardization constraint is</p>
<div class="math notranslate nohighlight">
\[(1/n) X^T X = I, \quad X^T \mathbf{1} = 0\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the number of items (i.e., the number of rows in <span class="math notranslate nohighlight">\(X\)</span>)
and <span class="math notranslate nohighlight">\(\mathbf{1}\)</span> is the all-ones vector.</p>
<p>A standardization constraint can be created with</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">constraint</span> <span class="o">=</span> <span class="n">pymde</span><span class="o">.</span><span class="n">Standardized</span><span class="p">()</span>
</pre></div>
</div>
<p>The standardization constraint has several implications.</p>
<ul class="simple">
<li><p>It forces the embedding to spread out.</p></li>
<li><p>It constrains sum of embedding distances to have a root-mean-square
value of <span class="math notranslate nohighlight">\(\sqrt{(2nm)/(n-1)}\)</span>, where <span class="math notranslate nohighlight">\(m\)</span> is the embedding
dimension. We call this value the natural length of the embedding.</p></li>
<li><p>It makes the columns of the embedding uncorrelated, which can be useful if
the embedding is to be used as features in a supervised learning task.</p></li>
</ul>
<p>When the distortion function is based on penalties and all the weights
are positive, you <strong>must</strong> impose a standardization constraint, which will
force the embedding to spread out. When the weights are not all positive,
a standardization constraint is not required, but is recommended: MDE
problems with standardization constraints always have a solution. Without
the constraint, problems can sometimes be pathological.</p>
<p>When the distortion functions are based on losses, care must be taken to ensure
that the original deviations and embedding distances are on the same scale.
This can be done by rescaling the original deviations to have RMS equal
to the natural length.</p>
</div>
<div class="section" id="anchored">
<h3>Anchored<a class="headerlink" href="#anchored" title="Permalink to this headline">¶</a></h3>
<p>The anchor constraint is</p>
<div class="math notranslate nohighlight">
\[x_i = v_i, \quad i \in \text{anchors}\]</div>
<p>where <span class="math notranslate nohighlight">\(\text{anchors}\)</span> is a subset of the items and <span class="math notranslate nohighlight">\(v_i\)</span>
is a concrete value to which <span class="math notranslate nohighlight">\(x_i\)</span> should be pinned.</p>
<p>An anchor constraint can be created with</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># anchors holds the item numbers that should be pinned</span>
<span class="n">anchors</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">])</span>
<span class="c1"># the ith row of values is the value v_i for the ith item in anchors</span>
<span class="n">values</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span>
  <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
  <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span>
  <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span>
<span class="p">])</span>
<span class="n">constraint</span> <span class="o">=</span> <span class="n">pymde</span><span class="o">.</span><span class="n">Anchored</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
<p>Below is a GIF showing the creation of an embedding of a binary tree,
in which the leaves have been anchored to lie on a circle with radius 20.</p>
<a class="reference internal image-reference" href="../_images/anchor_constraint.gif"><img alt="../_images/anchor_constraint.gif" src="../_images/anchor_constraint.gif" style="width: 50%;" /></a>
<p>See
<a class="reference external" href="https://github.com/cvxgrp/pymde/blob/main/examples/anchor_constraints.ipynb">this notebook</a>
for the code to make this embedding (and GIF).</p>
</div>
<div class="section" id="custom-constraints">
<h3>Custom constraints<a class="headerlink" href="#custom-constraints" title="Permalink to this headline">¶</a></h3>
<p>It is possible to specify a custom constraint set. To learn how to
do so, consult the <a class="reference internal" href="../api/index.html#api-constraints"><span class="std std-ref">API documentation</span></a>.</p>
</div>
</div>
<div class="section" id="computing-embeddings">
<h2>Computing embeddings<a class="headerlink" href="#computing-embeddings" title="Permalink to this headline">¶</a></h2>
<p>After creating an MDE problem, you can compute an embedding by calling
the its <a class="reference internal" href="../api/index.html#pymde.MDE.embed" title="pymde.MDE.embed"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">embed</span></code></a> method. The embed method takes
a few optional hyper-parameters. Here is its documentation.</p>
<dl class="py method">
<dt>
<code class="sig-prename descclassname">MDE.</code><code class="sig-name descname">embed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eps</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">300</span></em>, <em class="sig-param"><span class="n">memory_size</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">print_every</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">snapshot_every</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute an embedding.</p>
<p>This method stores the embedding in the <code class="docutils literal notranslate"><span class="pre">X</span></code> attribute of the problem
instance (<code class="docutils literal notranslate"><span class="pre">mde.X</span></code>). Summary statistics related to the fitting
process are stored in <code class="docutils literal notranslate"><span class="pre">solve_stats</span></code> (<code class="docutils literal notranslate"><span class="pre">mde.solve_stats</span></code>).</p>
<p>All arguments have sensible default values, so in most cases,
it suffices to just type <code class="docutils literal notranslate"><span class="pre">mde.embed()</span></code> or <code class="docutils literal notranslate"><span class="pre">mde.embed(verbose=True)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>torch.Tensor</em><em>, </em><em>optional</em>) – Initial iterate, of shape <code class="docutils literal notranslate"><span class="pre">(n_items,</span> <span class="pre">embedding_dim)</span></code>. When None,
the initial iterate is chosen randomly (and projected onto the
constraints); otherwise, the initial iterate should satisfy
the constraints.</p></li>
<li><p><strong>eps</strong> (<em>float</em>) – Residual norm threshold; quit when the residual norm
is smaller than <code class="docutils literal notranslate"><span class="pre">eps</span></code>.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em>) – Maximum number of iterations.</p></li>
<li><p><strong>memory_size</strong> (<em>int</em>) – The quasi-Newton memory. Larger values may lead to more stable
behavior, but will increase the amount of time each iteration
takes.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – Whether to print verbose output.</p></li>
<li><p><strong>print_every</strong> (<em>int</em><em>, </em><em>optional</em>) – Print verbose output every <code class="docutils literal notranslate"><span class="pre">print_every</span></code> iterations.</p></li>
<li><p><strong>snapshot_every</strong> (<em>int</em><em>, </em><em>optional</em>) – Snapshot embedding every <code class="docutils literal notranslate"><span class="pre">snapshot_every</span></code> iterations;
snapshots saved as CPU tensors to <code class="docutils literal notranslate"><span class="pre">self.solve_stats.snapshots</span></code>.
If you want to generate an animation with the <code class="docutils literal notranslate"><span class="pre">play</span></code> method after
embedding, set <code class="docutils literal notranslate"><span class="pre">snapshot_every</span></code> to a positive integer
(like 1 or 5).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The embedding, of shape <code class="docutils literal notranslate"><span class="pre">(n_items,</span> <span class="pre">embedding_dim)</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<p>Computing an embedding saves some statistics in the
<a class="reference internal" href="../api/index.html#pymde.optim.SolveStats" title="pymde.optim.SolveStats"><code class="xref any py py-class docutils literal notranslate"><span class="pre">solve_stats</span></code></a> attribute.</p>
</div>
<div class="section" id="sanity-checking-embeddings">
<h2>Sanity-checking embeddings<a class="headerlink" href="#sanity-checking-embeddings" title="Permalink to this headline">¶</a></h2>
<p>The MDE framework gives you a few ways to sanity-check embeddings.</p>
<div class="section" id="plotting-embeddings">
<h3>Plotting embeddings<a class="headerlink" href="#plotting-embeddings" title="Permalink to this headline">¶</a></h3>
<p>If your embedding is in three or fewer dimensions, the first thing to do
(after calling the <code class="docutils literal notranslate"><span class="pre">embed</span></code> method) is to simply plot it with <a class="reference internal" href="../api/index.html#pymde.plot" title="pymde.plot"><code class="xref any py py-func docutils literal notranslate"><span class="pre">pymde.plot</span></code></a>,
and color it by some attributes that were not used in the embedding process.
You can optionally pass in a list of edges to this function, which will
superimpose edges onto the scatter plot. Read the API documentation for
more details.</p>
<p>GIFs can be created with the <a class="reference internal" href="../api/index.html#pymde.MDE.play" title="pymde.MDE.play"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">pymde.MDE.play</span></code></a> method.</p>
</div>
<div class="section" id="the-cdf-of-distortions">
<h3>The CDF of distortions<a class="headerlink" href="#the-cdf-of-distortions" title="Permalink to this headline">¶</a></h3>
<p>Regardless of the embedding dimension, the next thing to do is to
plot the cumulative distribution function (CDF) of distortions. You can
do this by calling the <code class="docutils literal notranslate"><span class="pre">distortions_cdf</span></code> method on an MDE instance:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mde</span><span class="o">.</span><span class="n">distortions_cdf</span><span class="p">()</span>
</pre></div>
</div>
<p>This will result in a plot like</p>
<img alt="../_images/distortions_cdf.png" src="../_images/distortions_cdf.png" />
<p>In this particular case, we see that most distortions are very small, but
roughly 10 of them are much larger. This means that embedding
the items was “easy”, except for these 10 percent of edges.</p>
</div>
<div class="section" id="outliers">
<h3>Outliers<a class="headerlink" href="#outliers" title="Permalink to this headline">¶</a></h3>
<p>Next, you should manually inspect the items in, say, the 10 most highly
distorted pairs; this is similar to debugging a supervised learning model by
examining its mistakes. You can get the list of edges sorted from most
distorted to least like so:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pairs</span><span class="p">,</span> <span class="n">distortions</span> <span class="o">=</span> <span class="n">mde</span><span class="o">.</span><span class="n">high_distortion_pairs</span><span class="p">()</span><span class="o">.</span>
<span class="n">highly_distorted_pairs</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
<p>In the case of a specific embedding of MNIST, some of these pairs ended up
containing oddly written digits, while others looked like they shouldn’t
have been paired:</p>
<img alt="../_images/mnist_outliers.png" src="../_images/mnist_outliers.png" />
<p>After inspecting the highly distorted pairs, you have a few options.
You can leave your embedding as is, if you think your embedding is reasonable;
you can throw out some of the highly distorted edges if you think they don’t
belong; you can modify your distortion functions to be less sensitive
to large distances; or you can even remove some items from your original
dataset, if they appear malformed.</p>
</div>
</div>
<div class="section" id="comparing-embeddings">
<h2>Comparing embeddings<a class="headerlink" href="#comparing-embeddings" title="Permalink to this headline">¶</a></h2>
<p>Suppose you want to compare two different embeddings, which have the same
number of items and the same embedding dimension. If you have an MDE instance,
you can evaluate the average distortion of each embedding by calling
its <code class="docutils literal notranslate"><span class="pre">average_distortion</span></code> method.</p>
<p>It can also be meaningful to compute a distance between two embeddings. The
average distortion is invariant to rotations and reflections of embeddings,
so two embeddings must first be <em>aligned</em> before they can be compared.</p>
<p>To align one embedding to another, use the <a class="reference internal" href="../api/index.html#pymde.align" title="pymde.align"><code class="xref any py py-func docutils literal notranslate"><span class="pre">pymde.align</span></code></a> function:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">aligned_embedding</span> <span class="o">=</span> <span class="n">pymde</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">embedding</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">another_embedding</span><span class="p">)</span>
</pre></div>
</div>
<p>This function rotates and reflects the source embedding to be as close to
the target embedding as possible, and returns this rotated embedding. After
aligning, you can compare embeddings by plotting them (if the dimension is 3 or
less), or by computing the Frobenius norm of their difference (this distance
will make sense if both embeddings are standardized, since that will put
them on the same scale, but it will make less sense otherwise).</p>
</div>
<div class="section" id="embedding-new-points">
<h2>Embedding new points<a class="headerlink" href="#embedding-new-points" title="Permalink to this headline">¶</a></h2>
<p>Suppose we have embedded some number of items, and later we obtain additional
items of the same type that we wish to embed. (For example, we might
have embedded the MNIST dataset, and later we obtain more images we’d like
to embed.)</p>
<p>We have two options for embedding the new points. We could of course combine
the new images with the old images and compute a new embedding. This however
will result in an entirely new embedding. We might instead want to embed
the new items, without changing the vectors for the old data. To do say,
we can solve a small MDE problem involving the new items and some of the old
ones: some edges will be between new items, and importantly some edges will
connect the new items to old items. The old items can be held in place
with an anchor constraint.</p>
<p>PyMDE provides all the tools needed to embed new points, while holding
the old ones fixed, but it does not yet have a high-level API for doing this.
We plan to add one soon.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="../preprocess/index.html" class="btn btn-neutral float-right" title="Preprocessing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="../getting_started/index.html" class="btn btn-neutral float-left" title="Getting started" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
By <a href="https://akshayagrawal.com">Akshay Agrawal</a>.

    <p>

    </p>

  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>